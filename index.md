# 一、基本概念

## 1. 总体概述

### C\C++ 的跨平台原理

.c/cpp 文件会被编译成不同的文件（可执行文件），以便在不同平台上运行。 比如 window 编译成 PE 格式文件。 Mac => Mach-o 、 Linux => ELF。

### java 的跨平台原理

.java =>编译后 => .class(字节码) => 运行在平台上的 JVM（JAVA 虚拟机） => 再编译成机器指令 => 在操作系统运行

### js 的跨平台原理

js => 浏览器（各平台浏览器） => 编译成机器指令 => 操作系统运行

### 网络模型

OSI 模型：国际标准化组织 ISO 在 1985 年制定，偏理论，有点偏离实际。
TCP/IP 协议：实际开发人员认可的协议模型。
学习研究：将 TCP/IP 层的网络接口层，分为和 OSI 模型一样，分为数据链路层和物理层。主要是为了做研究。

## 2.计算机中的通信基础

1. 需要得知对方的 IP 地址。IP 地址最终会被解析处理为 MAC 地址。

2. 最终是根据 MAC 地址（网卡地址），输送数据到网卡，被网卡接收。

3. 如果网卡发现数据的目标 MAC 地址是自己，就会将数据传递给上一层进行处理。

4. 数据包里包含：源 IP、目标 IP、源 MAC、目标 MAC

## 计算机之间的连接方式

### 1. 网线直连

需要使用交叉线（不是直通线）。连接后在一个局域网下便可以直接通信。
ping 走的是 ICMP 协议。

#### 计算机 ping 时发生了什么？

一个计算机 ping 一个 ip 时，首先发送一个 ICMP 协议，但目前只有源 ip 和目的 ip，并不知道对方的 MAC 地址。
所以此时计算机会发送一个 ARP 协议，目的 MAC 地址设为 FFFF.FFFF.FFFF.FFFF。全 F 的 MAC 地址代表广播，即发给所有和该计算机相连接的设备。
报文中会携带源 IP 地址和目的 IP 地址，源 MAC 地址，当收到消息的设备确认目的 IP 是自身时，向源设备返回消息。此时计算机确认 ip 地址的 MAC 地址。
ping 就可以使用 ICMP 协议正常通信了。并且缓存了 ip 地址的 MAC 地址。下一次 ping 时不再重复上述步骤。

一般多台电脑就不太适用了

### 2. 同轴电缆

各种设备连接到同一根电缆上。一台计算机发包时，沿着电缆发送给所有设备，包内会带有目标 MAC 地址，其他设备对比 MAC 地址不是自身时就丢包，不做处理。目的设备就可以精准地接收到包了。

特点

1. 半双工通信。所谓半双工就是同一时间只能沿着一个方向传输。 相对的全双工就是可以双向传输。
2. 容易冲突。 不管是半双工的特点还是发送给所有设备的特点。 一台计算机发送消息时，其他计算机无法发送消息，处理机制是会等待一个随机数，等待过后再检测是否有消息正在传输，以此类推。
3. 不安全。 包发给了所有连接着的设备。虽然正常情况下非目的设备会丢包，但是使用一些抓包工具或者特殊手段，仍然有办法拿到包
4. 电缆任意一处断了，导致整个网络瘫痪。 同轴电缆必须是封闭的，两端都会有电阻。使得电信号到此就结束。 如果有一段中断可能造成信号回传（这一点不太理解，断了和电阻有区别？应该也是电信号结束啊）

### 3. 集线器（Hub）

集线器比之同轴电缆，不再是所有设备连接在一根电缆上，而是所有设备通过电缆和集线器（类似于中心服务器，不过是物理连线的）相连。通信时设备将消息发送给集线器，集线器再将消息发送给其它
连接着的设备。集线器与集线器相连，就能组成更大的网络。

特点：

1. 半双工通信：一台设备在向集线器发送消息的同时是不能接受集线器的消息的。
2. 容易冲突：集线器无法同时接受和发送消息。
3. 不安全
4. 跟同轴电缆基本一样，没啥智商，每次消息都是广播，发给所有连接着的设备，所以说当连接着的设备很多时，效率是非常低的。

优点、进步：

1. 某一根电缆断了不影响其他设备间的通信。

### 4. 网桥

能够通过自学习得知每个接口那侧的 MAC 地址，从而起到隔绝冲突域的作用。
所谓自学习，就是每次有设备发送消息时，会带着源 MAC 地址，网桥就会记录该源 MAC 地址以及在哪一侧。
它的作用是，一旦记录的 MAC 地址比较完整。当同一侧的两台设备通信时，网桥就不会向连接着的其他侧发送包了。从而可以使不同侧同时通信。

### 5. 交换机

相当于接口更多的网桥。也可看成是网桥和集线器的集合。交换机是局域网通信的最终方案。

交换机是直接和设备端相连的，并且在设备发送消息时记录其 MAC 地址。所以一旦 MAC 地址记录较完整时，就会直接在两台设备间通信，而不会将消息发送给其他设备了。

特点：

1. 全双工通信，交换机组织的网络可以同时发送和接收消息。
2. 比集线器安全

思考：
全球所有的设备都用交换机连接会是什么情况？

首先交换机连接的是同一网段的设备，如果全球设备都用交换机，ip 不够用。其次设备首次通信时，只知道 ip 地址不知道 MAC 地址，所以会发送 ARP 广播，全球所有设备广播效率又会很低。即使在同一网段（同一个交换机相连）的两台设备想要通信，也会广播全球设备。 会造成广播风暴（到处充斥着广播）。

### 6. 路由器

网线直连、同轴电缆、集线器、网桥、交换机特点：

1. 连接的设备必须在同一网段
2. 连接的设备处在同一广播域（处在同一个网段就是处在同一个广播域了）。

路由器：

1. 可以在不同网段之间发送数据
2. 隔绝广播域，广播只在路由器的一端进行。

主机发送数据前、首先会判断目标主机的 IP 地址跟它是否在同一个网段

1. 在同一个网段：
   ARP 广播获得目的 MAC 地址 、通过交换机/集线器等等传输
2. 不在同一个网段：
   通过路由器转发数据。具体流程：
   源主机 ARP 广播（目的 ip 为源主机网关地址） => 路由器端的设置的源主机网关地址 => 根据目的 IP 地址到达路由器端设置的目的网关 => 目的主机

   首先源主机发送 ARP 广播，但是这个广播不是为了获得目的 MAC 地址，而是获得该网段的网关 MAC 地址。所有这里有两个前提，首先源主机配置了网关地址，这样当发送不同网段的数据时，数据包中携带的目的 IP 就是网关 ip 地址。 第二就是源主机网段连接路由器的一端配置的 ip 地址即为该网关地址。 这样 ARP 广播就能顺利获取到该段的网关 MAC 地址了。 接下来根据数据包里的目的 ip 地址，路由器在其内部找对应的端口（即目的网关），找到后再从网关发送到目的主机上。流程结束。

   网关地址的最后一位一般配置成 1（非必须，可任意配置）

<!-- ************************************************************************************ -->

# 二、MAC 地址

     每一个网卡都有一个 6 字节（48bit）的 MAC 地址（Media Access Control Address）。

全球唯一，固化在了网卡的 ROM 中，由 IEEE802 标准规定。
前 3 字节：OUI（Organizationally Unique Identifier），组织唯一标识符。由 IEEE 的注册管理结构分配给产商。
后 3 字节：网络接口标识符。由产商自行分配。

如： 40-55-85-0A-8C-6D
一个 16 进制数代表 4 位（二进制），所以 2 个 16 进制就是 1 字节，所以 MAC 地址就是 12 个 16 进制数，6 字节表示。
顺便说一下，十进制下 1 个字节就是 0-255。所以为什么经常看到 255
MAC 地址查询：

1.  产商表： http://standards-oui.ieee.org/oui/oui.txt
2.  MAC 地址信息查询：https://mac.bmcx.com/

## MAC 地址的表示格式

- window：40-55-85-0A-8C-6D

- linux、Android、Mac、IOS：40:55:85:0A:8C:6D
- Packet Tracer: 4055.850A.8C6D
- 当 48 位全为 1 时，即 FF-FF-FF-FF-FF-FF，代表广播地址

  ## MAC 地址的操作

      计算机的 MAC 地址是可以修改的，如下所示，如果不配置默认就是使用网卡中的 MAC 地址。

  1.  更改适配器选项 - 属性 - 配置 -高级 -网络地址
  2.  填写的时候需要把减号（-）去掉。

  有时候可以通过修改 MAC 地址蹭网。一些大型局域网往往限制了接入的 MAC 地址。如果你知道了某一个能够接入的 MAC 地址，就能够通过修改自己的 MAC 地址去蹭网

  ## MAC 地址的获取

  当不知道对方主机的 MAC 地址时，可通过发送 ARP 广播获取对方的 MAC 地址

  1.  获取成功后，会缓存 IP 地址、MAC 地址的映射信息，俗称 ARP 缓存
  2.  通过 ARP 广播获取的 MAC 地址，属于动态（dynamic）缓存。ARP 缓存可通过命令行删除： arp -d [ip]（删除一个）、arp -d (删除所有)。也可通过命令行添加静态缓存： arp -s [ip] [MAC]。
  3.  动态缓存存储时间比较短，一般是 2 分钟。静态存储时间比较长，一般关机前都存在，甚至重启后也存在。不同操作系统对动静态缓存的存储时间有差异。

# 三、IP 地址

IP 地址（Internet Protocol Address）：互联网上的每一个主机都有一个 IP 地址

- 最初是 IPV4 版本，32bit（4 字节），2019 年 11 月 25 日，全球的 IP 地址已经用完
- 后面推出了 IPv6 版本，128bit（16 字节）

  ## IP 地址的组成

      IP 地址由 2 部分组成：网络标识（网络 ID）、主机标识（主机 ID）

1.  同一网段的计算机，网络 ID 相同
2.  通过子网掩码（subnet mask）可以计算出网络 ID：子网掩码 &（按位与） IP 地址。

比方说 192.168.1.10 的子网掩码位 255.255.255.0，那么前 3 字节就是该 ip 的网络 ID，即处在 192.168.1 网段，最后 1 个字节就是留给该网段的主机 ID，总共可以配置 256-2。不能配置为全 0 或者全 1。主机位全 0 代表网段。主机位全 1 代表广播。
但是如果子网掩码为 255.255.0.0，那么前 2 字节才是该 ip 的网络 id，即处在 192.168 网段。最后 2 个字节是主机 ID，总共可以配置 256\*256-2 个 ip。

计算机和其他计算机通信前，会先判断目标主机和自己是否在同一网段。

## IP 地址的分类

1.  A 类地址：默认子网掩码是 255.0.0.0
    8bit 网络 ID，第一位必须以 0 开头，24bit 主机 ID
2.  B 类地址：默认子网掩码是 255.255.0.0
    16bit 网络 ID，必须以 10 开头，16bit 主机 ID、
3.  C 类地址： 默认子网掩码是 255.255.255.0
    24bit 网络 ID，必须以 110 开头，8bit 主机 ID
4.  D 类地址：以 1110 开头，多播地址
5.  E 类地址：以 1111 开头，保留为今后使用

注意事项：

- 只有 A/B/C 类地址才能分配给主机
- 主机 ID 全为 0，代表主机所在网段
- 主机 ID 全为 1，表示主机所在网段的全部主机（广播）

### A 类地址

必须以 0 开头
网络 ID：因为第一位固定为 0 了，那么第一个字节还剩下 7 位，范围为 0-127，但是网络 ID 是不允许为全 0 的，所以是 1-127,而 127 是作为保留网段也不可用（熟悉的 127.0.0.1，为本地环回地址(Looback)）。
所以 A 类地址网络 ID 的范围实际为 1-126。只要 ip 地址第一部分为 1-126，就是 A 类地址了。A 类地址能够分配 126 个网段。
主机 ID，第 2、3、4 字节部分的取值范围为 0-255。
每个 A 类网络能容纳的最大主机数：256*256*256 -2 = 2 的 24 次方-2 = 16777214 (-2 是因为全 0 代表网段、全 1 代表广播。)

### B 类地址

必须以 10 开头
范围为 10000000 00000000 ~ 1011 1111。 即 128.0 ~ 191.255。

网络 ID
可以分配给主机的： 第一个字节 128~191、第二个字节 0-255
主机 ID：256\*256-2 = 65534

### C 类地址

必须以 110 开头
范围为 11000000 00000000 00000000 ~ 11011111 11111111 11111111。 即 192.0.0 ~ 223.255.255

网络 ID
第一个字节：192~223
第二、三字节：0~255

主机 ID
第 4 字节取值：0-255
C 类网络能容纳的最大主机数：256-2=254

### D 类地址、E 类地址

D 类地址：没有子网掩码，用于多播（组播）地址。第 1 部分取值：224~239
E 类地址：保留为今后使用，第 1 部分取值范围 240~255

### 子网掩码的 CIDR 表示方法

CIDR（classless Inter-Domain Routing）: 无类别域间路由
例子：
192.168.1.100/24 ,代表子网掩码有 24 个 1，也就是 255.255.255.0
123.210.100.10/24，代表子网掩码有 16 个 1，255.255.0.0

计算工具： https://www.sojson.com/convert/subnetmask.html

## 为什么要进行子网划分？

主要目的是为了合理利用资源。

如果一个局域网部署 200 台主机，那么用 C 类地址，分配一个网段即可，利用率 200/256。 ok
如果一个局域网需要部署 500 台主机，那么 C 类不够用，分配一个 B 类地址网段，利用率 500/65534。就属于比较大的资源浪费了。

### 子网划分

概念：借用主机位作子网位，划分出多个子网。

1. 等长子网划分：将一个网段等分成多个（2 的指数倍）子网，每个子网的可用 IP 地址数量是一样的
2. 变长子网划分：每个子网的可用 IP 地址数量可以是不一样的

#### 等长子网划分

子网划分步骤：

1. 确定子网的子网掩码长度
   以 C 类地址举例 192.168.0.0，其默认子网掩码为 255.255.255.0，那么它可以分配的 IP 为 192.168.0.1 ~ 192.168.0.254
   将它划分子网段，首先就是将子网掩码向右补 1，默认子网掩码最后 1 字节为 0，将该字节的首位设置为 1、即 255.255.255.[10000000]。

   这里要注意，子网掩码设置为 1，ip 与之对应的位就变为了网络 ID，那么主机 ID 此时只剩下 7 位了，同时多了两个网段，因为子网掩码设置为 1 的那位，对应的网络 ID 可以是 0 或者 1，这就是划分出的 2 个子网。

   这两个子网的范围就是 192.168.0.1 ~ 192.168.0.126（127 为主机 ID 全 1，代表广播）、 192.168.0.129（128 主机 ID 全 0，代表网段） ~ 192.168.0.254。 每个子网共有：126 个 ip
   所以可以持续对网段进行子网划分，子网掩码后移 n 位，就划分出了 2 的 n 次方 个子网，子网主机 ID 的长度（位数）就是原网段的 1/2 的 n 次方。

2. 确定子网中第 1 个、最后 1 个主机可用的 IP 地址

思考题：192.168.0.10/24 和 192.168.10.10/16 能正常通信嘛？

不可以， 192.168.10.10/16 的网段为 192.168.0.0/16，而 192.168.0.10/24 的网段为 192.168.0.0/24
192.168.10.10/16 可以和任意 192.168.xxx.xxx 通信。 192.168.0.10/24 可以与任意 192.168.0.xxx 通信
那么 192.168.10.10/16 可以发数据给 192.168.0.10/24，但是反过来则不可以。

老师思路：
1 台主机发送消息时会先判断对方 ip 和自己是否在同一网段，那么怎么得知对方网段呢？ 因为主机发消息前是只知道对方 ip 的，并没有对方的子网掩码。
所以它是拿 目的 ip 和源子网掩码进行按位与。 192.168.0.10/24 拿了目的 ip 192.168.10.10 和自己 24 位子网掩码进行按位与后，得出目的网段为 192.168.10.0，和自己不处于同一网段，会发给网关地址等等，所以此路就不通了，但是反过来可以。和上面自己的思路结论是一样的。

#### 变长子网划分

子网掩码不同，划分出的子网段就是不等长的。因为子网段 A 的子网掩码向右移动了 2 位，那么它的子网长度就是原来的 1/4；
子网段 B 的子网掩码向右移动了 4 位，那么它的子网长度就是原来的 1/16。 这样就是变长子网划分。

### 超网

超网：跟子网反过来，它是将多个连续的网段合并成一个更大的网段。重点连续的，不连续是不可以的。

将子网掩码向左移动，即可实现超网，网络 ID 位数减小，主机 ID 位数增多。可分配的 IP 地址就会增加。
比分说有两个网段 192.168.0.0/24,192.168.1.0/24，可以合并成超网：192.168.0.0/23。

需求：原本有 200 台计算机使用 192.168.0.0/24 网段，现在希望增加 200 台设备到同一个网段。

方法 1：通过分配一个 B 类地址，划分子网就可办到。
方法 2：分配一个 C 类地址，合并网段也可。在这个场景下，超网的方式各合适，因为 C 类地址子网掩码只需要向左移动 1 位，就完成需求。

思考： 192.168.0.255/23 这个 ip 地址，可以分配给计算机使用吗？

可以，主机 ID 部分并不是全 0 或者全 1。因为子网掩码向左移动了 1 位，所以此时的全 1 应该是 192.168.1.255 。

思考：192.168.1.0/24 和 192.168.2.0/24 两个网段可以通过子网掩码向左移动 1 位进行合并吗？
不可以。192.168.1.0/24 子网掩码向左移动 1 位只能合并 192.168.1.0/24 和 192.168.0.0/24，

合并网段规律：
如果想通过左移 1 位实现合并，需满足：

1. 必须是连续的，因为左移 1 位只能合并 2 个 ip。
2. 第一个网段必须能被 2 整除（10 进制表示时），若由二进制表示，则最后一位是 0.

它的本质就是转成二进制表示后，左移一位，网络 ID 部分相同，则代表可合并。

如果想通过左移 2 位实现合并，需满足：

1. 连续，
2. 第一个网段能够被 4 整除。二进制表示就需以 00 结尾。以此类推

### 判断一个网段是子网还是超网

1. 判断该 ip 的类型，A/B/C
2. 获知该类型的默认子网掩码，A（8），B（16），C（24）
3. 如果该网段的子网掩码位数比默认子网掩码多，就是子网;如果该网段的子网掩码位数比默认子网掩码少，则是超网。

   25.100.0.0/16 是一个 A 类子网
   200.100.0.0/16 是一个 C 类超网

# 路由

在不同网段之间转发数据，需要有路由器的支持
默认情况下，路由器只知道跟它直连的网段非直连的网段需要通过静态路由、动态路由告诉它。
举例：A 路由器跟 B 路由器相连，A 无法知道 B 路由器连接着的设备网段，只能知道 A 自身连接着的设备网段。

1. 静态路由：
   管理员手动添加路由信息，适用于小规模网络
2. 动态路由：
   路由器通过路由选择协议（比如 RIP、OSPF）自动获取路由信息，适用于大规模网络。

练习题 1：
让 4 台主机之间互相通信（4 个不同网段，使用两台路由器，使用静态路由）
192.168.1.10/24
192.168.2.10/24
193.169.1.10/24
193.169.2.10/24

实验步骤：

1. 配置好 4 台 pc、4 台交换机、两个路由器，并且连接起来，这里有一个疑问，为什么 pc 不能直接跟路由器相连，一定要通过交换机中转？ 疑问解除：pc 可以直接连路由器，这里只是例子中用了交换机而已。
2. 配置 PC 的网关地址，和连接路由器端口的地址一致，此时路由器直连的端口，这些网段之间已经能够通信。
3. 配置路由器和路由器直连的两个端口。交换机连接着路由器的端口类型是 fastEthernet，而路由器和路由器连接的端口类型为 serial 端口。
   配置 serial 端口的 ip 和掩码，要求是和直连路由器的端口不在同一网段。 两个路由器相连的 serial 端口 ip 必须在同一网段，因为他们两个之间是网线直连，不在同一网段无法通信。
4. 配置路由器的静态路由。 添加 1 个静态路由，网络和掩码填写目的 IP 的网段和掩码，下一跳填写与之相连的路由器端口 ip。这个配置什么意思呢？
   就是路由器接收到消息，在路由表中找到该地址属于某个静态路由的网段，就将包发送给该静态路由下一跳的地址。

注意：

1. 路由器的端口默认是关的，要打开后才会通
2. 点击左上角的放大镜（检查）可以查看路由器的路由表，类型 C（connect）代表直连端口路由，类型 S（static）代表静态路由。
3. 本质是通过命令行界面添加，所以可以通过命令行添加静态路由，太专业，后续有需要再学习。
4. 可通过将静态路由的网络和掩码配置的大一点，也就是网络掩码全 1 个数较少。如 255.0.0.0，那网段就只会是第一部分，比如 192.0.0.0，所有 192 开头的目标地址都走该路由了。 再继续延伸，将网络和掩码都配置为 0.0.0.0，就是默认路由，即如果静态路由表中没找到就去这个地址。 当然，越精确的地址匹配优先级越高。

练习题 2:

让以下四台主机可以互相通信
192.168.1.10/24
193.169.1.10/24
194.170.1.10/24
195.171.2.10/24

解答：和练习 1 解题思路类似，但是这 4 台主机都不在同一网段，所以需要使用 4 台路由器。
为方便配置。边缘两台路由器可配置静态路由 0.0.0.0，因为其只和某一台路由器相连接。
中间两台路由器，所到网段多的一端配置默认路由，另一端配置具体路由即可。
实际试验在 practices/static-router2.pkt 中。

# 四、局域网

## 数据包的传输过程

### 简述

数据包在交换机路由器之间传递时，源 IP 和目标 IP 一直是不变的，但是源 MAC 和目标 MAC 一直在变。
原因是源 MAC 发送给最终的目标 MAC，但是无法通过 ARP 广播直接获取到最终目标 MAC，只能先获取到网关 MAC 地址，然后一步一步走到最终目标 MAC。如果不这样做，路由器等各个网卡接收到数据包，发现目标 MAC 不是自己就会抛弃。路由器接收到数据后，根据目标 ip，再查询路由表，再更改目标 MAC 地址，发送到吓一跳。如此反复。。 直到找到最终的目标主机。

有个问题说一下，当不同网段主机首次通信时，ping 时第一次经常会超时。原因是第一次到达路由器后，路由器需要去获取另一端的 mac 地址，处理不过来，先将第一个包丢掉。获取到目的 MAC 地址后，存储在路由表里，第二个包就整成通信了。

## 概念扫盲

1. 网络（Network）：将多台计算机连接起来
2. 互联网（internet）：用路由器将不同网段连接起来
3. 因特网（Internet）：全世界最大的互联网。
   日常生活中说的上网、上外网就是指访问因特网。

### ISP

ISP（Internet Service Provider）Internet 服务提供商，比如移动、电信、网通、铁通等
我们平时拉的宽带都是通过 ISP 连接到 Internet 的

### 网络分类（了解）

按照网络的范围进行分类，可以分为：局域网、城域网、广域网等

1.  局域网：一般是范围在几百米到十几公里内的计算机所构成的计算机网络
    常用于公司、家庭、学校、医院、机关、一幢大楼等
    局域网中使用最广泛的网络技术叫：以太网（Ethernet）
    在电脑、手机上经常见到的一个英文 WLAN（Wireless Local Area Network），意思是无线局域网
2.  城域网（Metropolitan Area Network，MAN） 一般范围是数十公里到数百公里，可以覆盖一个城市
3.  广域网（Wide Area Network，WAN） 一般范围是几百公里到几千公里，可以覆盖一个国家。通常都需要租用 ISP 的线路。

### 常见的几种接口

以太网口：一般用在局域网内，就是平常见到的网口。

1. FastEthernet：快速以太网接口（100M）
2. GigabitEthernet：千兆以太网接口
3. Serial: 串行接口

### 上网方式

1. 电话线入户

即平时所说的：ADSL（Asymmetrical Digital Subscriber Line）,电话拨号上网。
非对称数字用户线路，提供上、下行不对称的传输带宽。
上行：数据传输给服务器
下行：从服务器获取数据
非对称：更多需要是从服务器获取数据，将数据传输给服务器的场景较少。 所以更多的带宽是给到获取数据

电话线路 => 猫的电话线接口 => 猫的网线接口 => 路由器 WAN 口 => 路由器 LAN 口 =>电脑主机网口

猫（Modem）：调制解调器，进行数字信号和模拟信号的转换。
因为电话线传输的是模拟信号，但是计算机传输给网线的是数字信号。 所以使用电话线进行网络传输，先要把数字信号转换为模拟信号，就时通过猫进行。

2. 光纤入户（现在用的较多）

入户光纤 => 光猫 PON => 路由器 WAN => 路由器 LAN => 电脑主机网口

光猫：光调制解调器，进行数字信号和光信号的转换。

3. 网线入户

这种方式一般小区还是接的光纤，然后统一转换后再练到各层各户的网线
入户网线 => 路由器 WAN => 路由器 LAN => 电脑主机网口

## 公网 ip & 私网 IP

公网 IP（Public）

- Internet 上的路由器只有到达公网的路由表，没有到达私网的路由表。
- 公网 IP 由因特网信息中心（Internet Network Information Center,Inter NIC ）统一分配和管理
- ISP 需要向 Inter NIC 申请公网 IP

私网 IP（Private）
主要是用于局域网。下面是保留的私网网段：

- A 类：10.0.0.0/8，1 个 A 类网络
- B 类：172.16.0.0/16 ~ 172.31.0.0/16，16 个 B 类网络
- C 类：192.168.0.0/24 ~ 192.168.255.0/24，256 个 C 类网络

## NAT

NAT：Network Address Translation
私网 IP 访问 Internet 需要进行 NAT 转换为公网 IP， 这一步可以由路由器来完成。

NAT 的特点：

1. 可以节约公网 IP 资源（局域网内的 ip 使用私网 IP 即可，对外只需要使用一个公网 IP）；
2. 隐藏内部真实 IP;

NAT 的分类：

1. 静态转换
   手动配置 NAT 映射表
   一对一转换（一个私网 IP 对应一个公网 IP）
2. 动态转换
   定义外部地址池，动态随机转换
   一对一转换
3. PAT （ Port Address Translation）
   多对一转换，最大程度节约公网 资源
   采用端口多路复用方式，通过端口号标识不同的数据流
   目前应用最广泛的 实现方式

# 五、网络互连模型

1.  OSI 参考模型（Open System Interconnect Reference Model）,具有 7 层结构。 --偏理论
2.  TCP/IP 模型 -- 实践经验得出
3.  学习研究 -- 将 TCP/IP 模型的最后一层分为数据链路层和物理层（OSI 模型的最后两层）。 -- 我们学习也是使用该模型。

为什么要分层：个人理解就是分模块，网络传输从硬件到软件太复杂，如果只有一层，不利于模块化。也不利于维护，需要懂得软硬件全部知识。就和前后端分离是差不多的原因。

网络传输过程如下图所示：
![](./iamges/网络传输模型.png)
应用层要传输一个数据，会经过模型的其他几层，在每一层都会添加首部，数据链路层还会添加尾部。将其封装后最后通过线路传输。

网络分层如下所示：
![](./iamges/网络分层.png)

## 不同协议网络模型不同

不是每个协议都会经历五层模型。
比如数据链路层的 PPP 协议和 CSMA/CD 协议，这两个协议是工作在数据链路层的协议，他们是不会经历应用层、传输层和网络层的。
再比如 ARP、ICMP 等网络层协议，是直接工作在网络层的，对这些协议来说就只有 3 层网络模型，直接一上来就在网络层将数据封装好传递给链路层，然后链路层再经历封装后传输给物理层

# 六、物理层（Physical）

物理层定义了接口标准、线缆标准、传输速率、传输方式等。

## 数字信号 & 模拟信号（了解）

模拟信号：

1.  连续的信号，适合长距离传输
2.  抗干扰能力差，受到干扰时波形变形，很难纠正。

数字信号：

1.  离散的信号，不适合长距离传输
2.  抗干扰能力强，受到干扰是波形失真可以修复

## 数据通信模型（了解）

1. 局域网通信模型：
   注意：网线一般不超过 100 米
   PC = 网线（数字信号）=> 集线器/交换机 = 网线（数字信号） => PC

2. 广域网通信模型：

   PC（A） = 网线（数字信号） => 调制解调器（A） = 电话线（模拟信号） => 调试解调器（B） =网线（数字信号） => PC（B）

   上图是电话线传输，如今也有很多光纤传输，和上图模型基本类似，只不过调制解调器不再是转换数字信号和模拟信号，而是转换数字信号和光信号，电话线也替换为光纤即可。

## 信道（了解）

信道：信息传输的通道，一条传输介质（比如网线）上可以有多条信道
比如进行 A 和 B 同时向对方发消息，实际上就是通过了 2 条信道，但是网线是同一根。

- 单工通信：
  信号只能往一个方向传输，任何时候都不能改变信号的传输方向。比如无线电广播，有限电视等。不存在电视需要向电视台发送数据的场景，所以使用单工即可。

- 半双工通信：
  信号可以双向传输，但是必须是交替进行，同时一时间只能往一个方向传输。比如对讲机（老式），有人说话时其他人不能说话。
- 全双工通信：
  信号可以同时双向传输（比如手机，打电话时可以同时说和听）

# 七、数据链路层（Data Link）

链路：从 1 个节点到相邻节点的一段物理线路（有限或无线），中间没有其他交换节点。

路由器、交换机之间的传输就是一段链路，但是集线器不算，集线器本身就相当于网线，没有做处理。但是路由器和路由器的通信和交换机是不同的，路由器和路由器通信会修改数据的目标 MAC 地址，而如果是交换机中转则不会。

数据链路：在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输。
不同类型的数据链路，所用的通信协议可能是不同的。

广播信道：CSMA/CD 协议（比如同轴电缆、集线器等组成的网络）
点对点信道：PPP 协议（比如 2 个路由器之间的信道）

数据链路层的 3 个基本问题（了解即可）：

1. 封装成帧
2. 透明传输
3. 差错检验

### 封装成帧

结构： 帧首部（SOH，含帧开始符） == 帧的数据部分 == 帧尾部（EOH，包含帧结束符）

- 帧（Frame）的数据部分：
  就是网络层传递下来的数据包（IP 数据包，Packet）
- 最大传输单元 MTU（Maxinum Transfer Unit）
  每一种数据链路层协议都规定了所能够传送的帧的数据长度上限。帧的数据部分不能超过 MTU 大小
  如以太网（CSMA/CD 协议）的 MTU 为 1500 个字节 。

### 透明传输

数据部分一旦出现 SOH、EOH，就需要进行转义。否则被误当做开始会结束帧，数据就不对了。
之所以较透明传输就是因为你发送的原始数据和接收到的数据之间可能在协议内转义了，这外部不被感知。

### 差错检验

FCS：根据帧的数据部分和帧首部（去除帧开始符）计算得出
帧尾部包含 FCS。帧发送时会先计算得到 FCS，一起传输给接收方。
接收方接到数据后，也会计算一遍 FCS，如果两者一致，代表数据传输 ok，如果不一致网卡就会丢弃。

不同协议帧首部和帧尾部的封装可能是不一样的。所以如果数据从一种链路传递到了另一种数据链路，那就会先将原帧的首部和头部去除，拿到帧的数据部分，再封装上自己协议的帧首部和帧尾部进行传输。 这就会造成不同数据链路的比特流可能会不同

## CSMA/CD 协议

CSMA/CD（Carrier Sense Multiple Access with Collision Detectio）协议 （如集线器应用）
载波侦听多路访问/冲突检测

载波侦听：侦听信道上是否有信号正在传输，在单工或半双工通信中应用。
多路访问：就是连接着的设备都可以发送信号
冲突检测: 如果信号传输过程中产生了冲突,则会被弹回。冲突检测就是检测出收到的信号是来自其他设备的传输信号。还是自身发出信号的回弹。

◼ 使用了 CSMA/CD 的网络可以称为是以太网（Ethernet），它传输的是以太网帧

- 以太网帧的格式有：Ethernet V2 标准（使用最多）、IEEE 的 802.3 标准
- 为了能够检测正在发送的帧是否产生了冲突，以太网的帧至少要 64 字节
- 用交换机组建的网络，已经支持全双工通信，不需要再使用 CSMA/CD，但它传输的帧依然是以太网帧
- 所以，用交换机组建的网络，依然可以叫做以太网

## Ethernet V2 帧的格式

结构： 目标 MAC 地址（6 字节） | 源 MAC 地址（6） | 类型（2）| 数据 | FCS （4）

这种格式的帧到了物理层的结构：

      插入8字节| 上方的以太网帧

      插入的8字节中，前7字节为前同步码，最后1字节为帧开始定界符。

首部：源 MAC + 目标 MAC + 网络类型（IPv4 or IPv6）
以太网帧：首部+数据+FCS
数据的长度至少： 64 - 6 - 6 - 2 - 4 = 46 字节

该中格式的帧是没有帧开始符和帧结束符，帧开始是用了物理层的帧开始定界符。以太网使用曼彻斯特编码，该编码根据信号跳变判断帧结束。

当数据部分的长度小于 46 字节时

1. 数据链路层会在数据的后面加入一些字节填充
2. 接收端会将添加的字节去掉

长度总结：

以太网帧的数据长度：46~1500 字节
以太网帧的长度：64~1518 字节（目标 MAC +源 MAC + 网络类型 + 数据 + FCS）

### PPP 协议

结构： 帧开始符 | Address | Control | 协议 | 数据部分 | FCS | 帧结束符

数据部分左边为首部、数据部分右边为帧尾部

帧开始符、帧结束符：0x7E
Address 字段：图中的值是 0xFF，形同虚设，点到点信道不需要源 MAC、目标 MAC 地址
Control 字段：图中的值是 0x03，目前没有什么作用
Protocol 字段：PPP 协议内部用到的协议类型

字节填充
即开始符和结束符的转义。如果数据部分有 7E，则转化为 7D5E,5E 即为字节填充，如果就是传输 7D，则转义为 7D5D。换句话说接收方收到 7D，则认为转义，如果跟着 5E，整个数据为 7E。如果跟着 5D，则数据为 7D

## 网卡

网卡工作在物理层和数据链路层。内部有 MAC 地址。

- 物理层：
  物理连接和数字信号同步、数据的编码与解码
- 数据链路层：
  帧的差错校验、帧的封装与拆封、介质访问控制（CSMA/CD）

  流程：
  网卡接收到比特流 => 进行差错校验 => 丢弃校验失败的帧，校验成功的帧拆封（去掉 FCS） =>向上传输

- 网卡接收到一个帧，首先会进行差错校验，如果校验通过则接收，否则丢弃
- Wireshark 抓到的帧没有 FCS ，因为它抓到的是差错校验通过的帧（帧尾的 FCS 会被硬件去掉）
- Wireshark 抓不到差错校验失败的帧

# 八、网络层（Network）

网络层数据包（IP 数据包，Packet）由首部、数据 2 部分组成
数据：很多时候是由传输层传递下来的数据段（Segment）

其结构包含首部和数据部分。首部又分为固定部分（20 个字节）和可变部分。很多时候只有固定部分。如下图所示
![](./iamges/网络层数据包结构.png)

首部包含（可通过 wireShark 抓包对比）着很多信息，下面重点分析。

## 1. 版本（Version）

占 4 位。0b0100：IPv4；0b0110：IPv6

## 2. 首部长度（Header Length）

占 4 位，二进制乘以 4 才是最终长度。0b0101：20（最小值、因为首部固定部分已经 20 字节了）；0b1111：60（最大值）

## 3. 区分服务（Differentiated Services Field）

占 8 位，可以用于提高网络的服务质量（QoS，Quality of Service）。
比如路由器发现某个包的网络层头部区分服务值不是 0，并且和路由器内设置的 Qos 值一致，则可让该数据包优先通过。

## 4. 总长度（Total Length）

占 16 位，首部 + 数据的长度之和，最大值为 65565 字节，2 的 16 次方。

- 之前说过，以太网数据链路层的 MTU 为 1500 字节，所以过大的 IP 数据包，需要分成片（fragments）传输给数据链路层。
- 每一片都有自己的网络层首部（IP 首部）

## 5. 标识（Identification）

占 16 位，数据包的 ID，当数据包过大进行分片时，同一个数据包的所有片的标识都是一样的。
有一个计数器专门管理数据包的 ID，每发出一个数据包，ID 就加 1（总共可以计 65565 个数据包 ID，一旦到 65535，就从头开始）

## 6. 标志（Flags）

占 3 位。

1. 第 1 位（Reserved Bit）：保留
2. 第 2 位（Don't Fragment）：1 代表不允许分片，0 代表允许分片
3. 第 3 位（More Fragments）：1 代表不是最后一片，0 代表是最后一片

## 7. 片偏移（Fragment Offset）

占 13 位。
片偏移乘以 8 = 字节偏移。 所谓字节偏移，就是该片是从数据包的第几个字节开始的。有了字节偏移，即可将片拼装成数据包了。 不直接表示字节偏移是担心数据包较大时，13 位表示不下字节偏移。
所以每一片的长度一定是 8 的整数倍。这样片偏移和字节偏移的对应才是准确的。

## ping 的 几种用法

后续实验需要使用

1. ping /?
   查看 ping 的用法
2. ping ip 地址 -l 数据包大小
   发送指定大小的数据包
3. ping ip 地址 -f
   不允许网络层分片
4. ping ip 地址 -i TTL
   设置 TTL 的值
5. 通过 tracert、pathping 命令，可以跟踪数据包经过了哪些路由器

## wireShark 实验

分析： ping juejin.cn -l 800

1. ICMP 协议查看下的：Total Length: 828。包含首部 20+数据部分 828（数据 800+ICMP 协议头 8）

分析： ping juejin.cn -l 4000
过滤条件 ip.addr = 地址

1. 分片传输，前几片 wireShark 还无法确定传输协议，所以显示的协议是 IPv4，所以无法使用协议 icmp 进行过滤。
2. Total Length: 前两片为 1500。刚好是帧数据部分的最大长度。最后一位为 1068。
   前两片 1500-20（首部长度），最后一片 1068 - 20 - 8（ICMP 协议头部）

total = (1500-20)\* 2 + (1068 - 20 - 8) = 4000 3. 标志（Flags）：前两片第三位（More Fragements）为 1，代表还有更多片，第三片为 0，代表无更多片了。 4. Identification: 同一个包三片的标识是一样的。

## 8. 生存时间（Time To Live TTL）

- 占 8 位
- 每个路由器在转发之前会将 TTL 减 1，一旦发现 TTL 减为 0，路由器会返回错误报告
- 观察 ping 命令后的 TTL，能够推测出对方的操作系统、中间经过了多少个路由器

| 操作系统 |           版本            | 默认 TTL |
| -------- | :-----------------------: | -------: |
| Windows  |  Server 2003、XP、7、10   |      128 |
| Linux    |  2.0X kernel、Red Hat 9   |       64 |
| Linux    | 2.2.14 kernel、2.4 kernel |      255 |
| Mac OS   |                           |       60 |
| Mac OS X |                           |       64 |

为什么要有生存时间：
比如两个路由器的默认路由都是对方（网管配置错误），如果没有 TTL，路由就死循环了。该包就会一直占用带宽。

## 8. 协议（Protocol）

占 8 位
表明所封装的数据是使用了什么协议

ICPM（1）、IGMP（2）、IP（4）、TCP（6）、EGP（8）、IGP（9）、UDP（17）、IPv6（41）、ESP（50）、OSPF（89）

## 9. 首部校验和（Header Checksum）

用于检查首部是否有错误。
发送前当首部其他字段已经拼装完毕，根据一定算法规则算出首部检验和。 接收方接收到后再计算一遍，进行对比。

## 10、源 IP 地址

占 4 字节

## 11、目标 IP 地址

占 4 字节

# 九、传输层（Transport）

传输层有 2 个协议：

1. TCP（Transmission Control Protocol），传输控制协议
2. UDP（User Datagram Protocol）,用户数据报协议。
   两个协议的特点对比如下图

![TCP And UDP](./iamges/TCPAndUDP.png)

但是不管是 TCP 还是 UDP，都会传递给网络层，封装成网络层的格式进行传输。

## UDP

- UDP 是无连接的，减少了建议和释放连接的开销
- UDP 尽最大能力交付，不保证可靠交付
  因此不需要维护一些复杂的参数，首部只有 8 个字节（TCP 的首部至少 20 个字节）

- UDP 组成：首部+数据
- UDP 首部包含：源端口号（16 位）、目的端口号（16 位）、UDP 长度（16 位）、UDP 校验和（16 位）。如下图所示：

![TCP结构](./iamges/UDP结构.png)

### UDP 首部- UDP 长度（Length）

占 16 位，首部的长度+数据的长度

### UDP 首部- 校验和（Checksum）

校验和的计算内容：伪首部 + 首部 +数据
伪首部：仅在计算校验和时起作用，并不会传递给网络层。包含源 IP 地址、目的 IP 地址、协议类型、UDP 长度等内容。加上伪首部是为了增强校验和，增加安全性。

### UDP 端口（Port）

- UDP 首部中端口是占用 2 字节，所以范围位 0~65535
- 客户端的源端口是临时开启的随机端口。
  它的作用是什么呢，比方说客户端发了两个 UDP 请求，当数据回传时，无法区分返回的数据是哪次请求的。而处理机制就是根据随机端口来的，以随机端口为标志标记本条 UDP 请求。请求结束后端口就会关闭。
- 防火墙可以设置开启\关闭某些端口来提高安全性
  比方说 MySQL 数据库的默认端口是 3306，那防火墙就可以设置 TCP 协议 3306 端口隔绝。只能内部访问 3306 端口，提高安全性。
- 常用命令行
  netstat –an：查看被占用的端口
  netstat –anb：查看被占用的端口、占用端口的应用程序
  telnet 主机 端口：查看是否可以访问主机的某个端口
  安装 telnet：控制面板 – 程序 – 启用或关闭 Windows 功能 – 勾选“Telnet Client” – 确定

  - 不同协议的默认端口

  | 协议  |  默认端口号  |
  | ----- | :----------: |
  | HTTP  |   TCP + 80   |
  | HTTPS |  TCP + 443   |
  | FTP   |   TCP + 21   |
  | MySQL |  TCP + 3306  |
  | DNS   | UDP/TCP + 53 |
  | SMTP  |   TCP + 25   |
  | POP3  |  TCP + 110   |

  ## TCP

  ### TCP 数据格式

  TCP 结构如下图所示：

![TCP结构](./iamges/TCP结构.png)

    TCP 的首部至少 20 字节，最大可以到 60 字节，为什么 TCP 的首部比 UDP 大很多，是因为 TCP 以下几个特点：

    1. 可靠传输
       如果丢包了会重传。
    2. 流量控制
       通过窗口大小字段，告知服务器传输速率。 比如 TCP 缓存空间快用完了，或者客户端网络差，处理不过来时，也可通过该字段，暂缓接收服务器数据
    3. 拥塞控制

    4. 连接管理

    5. 建立连接

    6. 释放连接

TCP 首部还有一个注意点，就是观察 UDP 发现：

- UDP 的首部中有个 16 位的字段记录了整个 UDP 报文段的长度（首部 + 数据）
- 但是， TCP 的首部中仅有个 4 位的字段记录了 TCP 报文段的首部长度，并没有字记录 TCP 报文段的数据长度。

原因：

- UDP 首部中占 16 位的长度字段是 冗余，纯粹为了保证首部 32bit 对齐，为什么要保证它是 32bit，4 字节对齐呢，因为长度（字节）很多时候是通过乘以 4 算出来的，如果字节数不是 4 的倍数。很容易出问题。
- TCP\UDP 的数据长度，完全可以由 IP 数据包的首部推测出来
- 传输层的数据长度 = 网络层的总长度 – 网络层的首部长度 – 传输层的首部长度

### TCP 首部 - 数据偏移

- 占 4 位，取值范围是 0x0101~0x1111
- 数据偏移 \* 4 = 首部长度(Header Length)
- 首部长度是 20~60 字节

以上三个特点和网络层的 “首部长度（Header Length）” 字段类似。为什么叫数据偏移呢，因为对于传输数据来说，TCP 首部就是偏移量。去除首部就 是获取的数据了。

### TCP 首部 - 保留

占 6 位，目前全为 0。

这里有一个注意点，有些资料中认为保留位只有 3 位，而标志位有 9 位，但是标志位的 9 位中。前 3 位目前也没有用到，所以也有些资料把标志位 的 前 3 位归为保留位。两种说法都可以。

### TCP 首部 - 检验和（Checksum）

- 跟 UDP 一样， TCP 检验和的计算内容：伪首部 + 首部 + 数据
- 伪首部：占用 12 字节，仅在计算检验和时起作用并不会传递给网络层

### TCP 标志位（Flags）

1. URG（Urgent）:
   当 URG = 1 时，紧急指针（首部另一个字段）字段才有效。表明当前报文段中有紧急数据，应优先尽快传送
2. ACK（Acknowledgment）：确认号
   当 ACK = 1 时，确认号（首部另一个字段）字段才有效
3. PSH（Push）：使用场景很少，暂且跳过

4. RST（Rest）：
   当 RST = 1 时，表明连接中出现严重错误，必须释放连接，然后再重新建立连接
5. SYN（Synchronization）：
   当 SYN = 1、ACK = 0 时，表明这是一个建立连接的请求
   若对方同意建立连接，则恢复 SYN = 1、ACK=1
6. FIN（Finsh）
   当 FIN = 1 时，表明数据已经发送完毕，要求释放连接

### TCP 首部 - 序号（Sequence Number ）

- 占 4 字节
- 首先，在传输过程的每一个字节都会有编号
- 在建立连接后，序号代表：这一次传给对方的 TCP 数据部分的第一个字节编号
  TCP 传输数据过大，要分多次传输时，序号就可以用来帮助拼装（个人理解）

### TCP 首部 - 确认号（Acknowledgment Number ）

- 占 4 字节
- 在建立连接后，确认号代表：期望对方下一次传过来的 TCP 数据部分的第一个字节编号
  也相当于告知对方你此前发过来的字节我已经收到，你下一次应该从数据的哪个字节开始发。比如已收到 1460，那返回的确认号就应该是 1461

### TCP 首部 - 窗口（Window）

- 占 2 字节
- 这个字段有流量控制功能，用以告知对方下一次允许发送的数据大小（字节为单位）

<!-- TCP首部内容结束，以下为TCP各特点详细说明 -->

### TCP 可靠传输

#### 可靠传输 - 停止等待 ARQ 协议

ARQ（Automatic Repeat–reQuest）自动重传请求

它的核心就是超时重传，超时有几种情况：

1. 客户端发的数据未到服务端
2. 客户端发的数据到服务端了，但是服务端发现数据有问题，直接丢包
3. 客户端发的数据到服务端了，服务端返回确认时没有到达客户端，客户端超时重传，服务端收到两个同样的包时，会把之前收到的包丢弃
4. 服务端收到确认返回给客户端时，因网络延迟迟到了，客户端超时重传，服务端同样丢弃重复包，再次发送确认。发送了两次确认，客户端对后一次确认忽略。

上述方式效率相对较低，所以后来发展出了以下方式：

#### 可靠传输 - 连续 ARQ 协议 + 滑动窗口协议

- 建立连接后，接收方 B 会同时发送窗口大小（接收方缓存可用空间）给发送方 A。
- 发送方 A 根据窗口大小将数据分包，比如窗口大小是 4000，而每次只能发 1500 字节，所以需要分 3 次发送。要注意的是，一个窗口内的 3 次 TCP 请求，可以连续发送，这就是连续 ARQ 的含义。而 B 只需要在窗口大小最后一次请求时返回确认报文。里面携带确认标志，以及确认号。
- A 只有在收到 B 的确认报文后，才会发送内存中下一个窗口数据，好比窗口滑动了，所以是窗口滑动协议。 其实 B 接收的数据也是先放在缓存中，当收到 A 下一次窗口数据时，也会将前一个窗口数据发送给应用程序，并从缓存中删除
- 如果 A 发送窗口数据过程中，第二个包丢失了，那么 B 返回的确认号只会从已经收到的第一段数据计算，比如 1480，虽然第三段数据也收到了，但是不能叠加。

- A 接收到 B 的确认号后，发现不是完整的窗口带下，就会从 1480 开始重传，将后面两个包再发送一次（现在有选择确认技术 - SACK，服务端可以选择确认，这样客户端明确知道第二个包丢失了，就只发送第二个包）。

- B 确认过程中会携带下一次窗口大小，窗口大小随着 B 主机的运行情况可能是会变的。

#### 选择性确认（SACK）

- 在 TCP 通信过程中，如果发送序列间某个数据包丢失（比 1、2、3、4、5 中的 3 丢失了）
- TCP 会通过重传最后确认的分组后续的分组（最后确认的是 2，会重传 3、4、5）
- 这样原先已经正确传输的分组也可能重复发送（比如 4、5），降低了 TCP 性能

为改善上述情况，发展出了 SACK（Selective acknowledgment，选择 性确认）技术

- 告诉发送方哪些数据丢失，哪些数据已经提前收到
- 使 TCP 只重新发送丢失的包（比如 3），不用发送后续所有的分组（比如 4、5）

SACK 信息会放在 TCP 首部的选项部分：

1. kind:占 1 字节，值为 5 代表这是 SACK 选项
2. Length ：占 1 字节。表明 SACK 选项一共占用多少字节
3. Left Edge：占 4 字节，左边界 （受到的一个数据包）
4. Right Edge：占 4 字节，右边界

一对边界信息需要占用 8 字节，由于 TCP 首部的选项分最多 40 字节，所以：

- SACK 选项最多携带 4 组边界信息
- SACK 选项的最大占用字节数 = 4 \* 8 + 2 = 34

#### TCP 几个问题

- 重传次数:
  若有个包重传了 N 次还是失败？ 会一直一直重传直到成功嘛？
  答：不会。取决于操作系统的设置，比如有部分系统，重传 5 次还未成功就会发送 reset 报文（RST），断开 TCP 连接。

- 发送方发送报文不足 接收方窗口大小时：
  如果接收方告诉发送方我的窗口大小为 400，而发送方只发送了 200，接收方接到 200 后会先等待一段时间，因为正常情况下是接收满窗口大小再返回确认报文的。等待一段时间没有数据再传过来时，返回确认报文。
- 为什么选择在传输层就讲数据“大卸八块”，分成多段。而不是等到网络层再分片传递给数据链路层。
  答： 因为可以提高重传的性能
  如果在传输层不分段，一旦出现数据丢失整个传输层的数据的都得重传
  如果在传输层分了段，一旦出现数据丢失只需要重传丢失的的那些段即可

  网络层和数据链路层不具备重传功能。如果再这两层分片，一旦丢包，导致接收方传输层拼装出来的数据和发送方传输层发送的数据不一致，接收方不会返回 ACK 给发送方。发送方未收到回复，一定时间后再次发送整个数据。

### 流量控制

如果接收方的缓存区满了，发送方还在疯狂着发送数据:
接收方只能把收到的数据包丢掉，大量的丢包会极大得浪费网络资源，所以要进行流量控制。

- 什么是流量控制？
  控制发送方的发送速率不要太快，使接收方来得及处理
- 原理
  通过确认报文中窗口字段来控制发送方的发送速率
  发送方的发送窗口大小不能超过接收方给出窗口大小
  当发送方收到接收窗口大小为 0 时（接收方缓存区满了，再发包就会大量丢包），发送方就会停止发送数据

  #### 特殊情况

  - 问题： 说一种特殊情况，接收方缓存用完，给发送方 返回了 0 窗口报文段。之后接收方又有了一些缓存空间，但是不巧给发送方的非 0 窗口报文段丢失了。那么如果这样发送方岂不是一直不能发数据给接收方了？

  - 解决方案：
    当发送发接收到 0 窗口通知时，发送方停止发送报文
    并且同时开启一个定时器，隔一段时间就发个测试报文去询问接收方最新的窗口大小
    如果接收的窗口大小还是为 0，则发送方再次刷新启动定时器。

### TCP - 拥塞控制

先看一下什么是拥塞：
![网络拥塞](./iamges/网络拥塞.png);

如上图，1000M 带宽只是理论上每秒能过 1000M 的包，实际到达大概 500 左右时就开始轻度拥塞了，700 时就拥塞了。在往上，800 以上拥塞情况越来越严重，如果持续正价到 1000 多甚至可能出现死锁，网络彻底瘫痪。

这种情况和交通十分类似。1000 辆车通行的道路，500 之前通过率一直递增。因为不堵车速度差不多。一旦再往上，交通拥堵通过率增长变慢，增长到 7、8 百时通过率反而降低了。 再往上交通瘫痪，可能就彻底不动了。

- 拥塞控制：
  防止过多的数据注入到网络中
  避免网络中的路由器或链路过载

- 拥塞控制是一个全局性的过程
  对比流量控制，流量控制是单对单（端对端）的，两台机器间完成的流量控制。但是拥塞控制无法靠几台设备完成。
  涉及到所有的主机、路由器
  以及与降低网络传输性能有关的所有因素。是所有这些因素共同努力地控制结果。

- 拥塞控制-方法：

  1. 慢开始
  2. 拥塞避免
  3. 快速重传
  4. 快速回复

- 几个缩写：

  1. MSS（Maximum Segment Size）：每个段最大的数据部分大小。
     在建立连接时确定。
     在 TCP 首部选项部分，一般为 1400 多，但不一定是 1460（1460 为最大值，1500-20-20）。
     如果发送方的 MSS 和接收方确认返回的 MSS 不一致，则取两者之前的最小值。
     所以很多情况下，建立连接的 TCP 请求首部，是 32 字节，除了固定的 20 字节以外，还有增加一些选项。如 MSS、window Scale、SACK permitted（允许选择性确认）

  2. rwnd（receive window）：接收窗口。最多一次连续发多少数据过来（可以理解为并发数量，接收方只给 1 个返回确认）

  3. swnd（send window）：发送窗口

  4. cwnd（congestion window）：拥塞窗口。根据网络状况调整的窗口大小。
     swnd = min（cwnd，rwnd）

  #### 拥塞控制 - 慢开始

  比如接收方窗口为 3000，但是 MSS 协商为 100（有个疑问，这个 MSS=100 是否是两方根据网络状况设置的），一旦 MSS 设置为 100 后，发送方的拥塞窗口就为 100。所以一开始只会发送 100 字节数据，即使接收方窗口为 3000。

  然后慢慢地增加，100 接收到确认后发送 200，确认后再发送 400，再发送 800 以此类推。

  - 慢开始：cwnd 的初始值（可以设置，TCP 内部也有默认值）比较小，然后随着数据包被接收方确认（收到一个 ACK），cwnd 就成倍增长（指数级）。

  #### 拥塞控制 - 拥塞避免

  - ssthresh（slow start threshold）：慢开始阈值，cwnd 达到阈值后，以线性方式增加
  - 拥塞避免（加法增大）：拥塞窗口缓慢增大，已防止网络过早出现拥塞
  - 乘法减小：只要网络出现拥塞（发送方根据丢包判断），就把 ssthresh 减为拥塞值的一半，与此同时，执行慢开始算法（cwnd 又恢复到初始值即最小值），这个是 TCP 旧版本的做法，新版本采用后面讲到的快速回复。不再从头执行慢开始算法。
  - 当网络出现频繁拥塞时，ssthresh 值就下降的很快

  #### 拥塞控制 - 快重传

  接收方：

  - 每收到一个失序的分组（即中间丢包了）后就立即发出重复确认。（比如收到 1,2,4,5，就会重复确认 2），
  - 使发送方及时知道有分组没有到达，立即重发。而不是等待一定时间后重发。

  发送方：

  - 只要连续收到三个重复确认（总共 4 个相同的确认），就应当立即重传对方尚未收到的报文段而不必继续等待重传计时器到期后再重传

  #### 拥塞控制 - 快恢复

  - 当发送方连续收到三个重复确认说明网络出现拥塞，就执行“乘法减小”算法，把 ssthresh 减半。
  - 与慢开始不同之处是现在不执行慢开始算法，即 cwnd 现在不恢复到初始值，而是把 cwnd 值设置为新的 ssthresh 值（减小后的）
    然后开始执行拥塞避免算法（“加增大大”），使拥塞窗口缓慢地线性增大。

  ![拥塞控制原理图](./iamges/拥塞控制原理图.png);

  #### 拥塞控制总结

  拥塞控制即通过调整发送窗口大小控制发送方的数据发送频率。

  发送窗口最大值 ： swnd = min(cwnd,rwnd)

  当 rwnd < cwnd ：接收方的接收能力限制发送窗口的最大值
  当 cwnd < rwnd： 网络的拥塞限制发送窗口的最大值

  ### TCP - 连接管理

  #### 连接管理 - 建立连接

  发送 HTTP 请求前，需要建立 TCP 连接，就会经过 TCP 三次握手。大致过程如下图所示：
  ![网络拥塞](./iamges/TCP建立连接.png);
  上图将 TCP 建立连接的每一步都标上了序号，下面开始详细分析：

  1. SYN = 1; ACK = 0： seq（相对值） = 0； ack（相对值） = 0； seq（原生值） = s1； ack（原生值） = 0；数据 = 0；
     首先客户端发送标志位 SYN = 1；代表建立连接请求。客户端 ACK 标志位为 0，因为此次请求客户端作为发送方不需要确认是否收到。seq 因为数据部分为 0，所以数据部分的第一个字节为 0。ack 作为发送方自然也为 0；
  2. SYN = 1; ACK = 1： seq（相对值） = 0； ack（相对值） = 1； seq（原生值） = s2； ack（原生值） = s1+1；数据 = 0；
     服务端返回确认报文。同时也是服务端向客户端建立连接的请求。所以 SYN=1；ACK = 1。数据部分为 0，seq 为 0，seq 原生值为 s2，服务单和客户端的 seq 原生值是独立的，两者没有关系。ack = 1；因为服务端已经接收到 0 个字节，期望客户端下次发送第 1 个字节。ack 原生值 = s1 + 1；
  3. SYN = 0; ACK = 1： seq（相对值） = 1； ack（相对值） = 1； seq（原生值） = s1+1； ack（原生值） = s2+1；数据 = 0；
     发送方同样返回确认报文给接收方，ACK = 1；但是此次请求不是建立连接请求了，在步骤 1 中已经建立了连接，所以 SYN = 0；
     <!-- TODO：数据部分为0，但seq = 1； -->

     特殊点：数据部分为 0，但 seq = 1；教程解释接收方的 ack= 1；这里配合接收方发送 seq = 1；个人觉得这个理由不成立。接收方期望下次数据从第 1 字节开始发，但是发送方没有发送数据，只是作为确认报文，按规则 seq = 0；
     ack = 1；因为发送方收到了接收方发送的 0 字节，下次期望从 1 字节开始接收。原生值就通过步骤 1、2 中得知的初始值 s1、s2 计算得出。

     以上就是 TCP 三次握手的详细过程，握手完成后就可以建立 HTTT 请求了。三次握手数据部分均为 0。

  4. 

  #### 连接管理 - 释放连接

  ### TCP 总结

  1. 可靠传输：将丢了的包进行重传
  2. 流量控制：点对点控制，通过窗口字段告知对方降低发送速率。
  3. 拥塞控制：网络中的所有设备根据一定规则保证整个网络的顺畅。规则：慢开始、拥塞避免（加法增大）、快重传、快恢复。
